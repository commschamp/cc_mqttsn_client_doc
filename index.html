<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MQTT-SN Client: MQTT-SN Client Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MQTT-SN Client
   </div>
   <div id="projectbrief">MQTT-SN client library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MQTT-SN Client Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cc_mqttsn_client_overview">Overview</a></li>
<li class="level1"><a href="#cc_mqttsn_client_io_links">Various I/O Links</a></li>
<li class="level1"><a href="#cc_mqttsn_client_header">Header</a></li>
<li class="level1"><a href="#cc_mqttsn_client_allocation">Client Allocation</a></li>
<li class="level1"><a href="#cc_mqttsn_client_setup">Client Setup</a></li>
<li class="level1"><a href="#cc_mqttsn_client_data_recv">Receiving Data</a></li>
<li class="level1"><a href="#cc_mqttsn_client_data_send">Sending Data</a></li>
<li class="level1"><a href="#cc_mqttsn_client_time_measurement">Time Measurement</a></li>
<li class="level1"><a href="#cc_mqttsn_client_gateways">Gateway Discovery</a></li>
<li class="level1"><a href="#cc_mqttsn_client_connect_disconnect">Connect / Disconnect</a></li>
<li class="level1"><a href="#cc_mqttsn_client_publish">Publishing</a></li>
<li class="level1"><a href="#cc_mqttsn_client_subscribe">Subscribing</a></li>
<li class="level1"><a href="#cc_mqttsn_client_unsubscribe">Unsubscribing</a></li>
<li class="level1"><a href="#cc_mqttsn_client_will">Updating the Will</a></li>
<li class="level1"><a href="#cc_mqttsn_client_sleep">Sleeping</a></li>
<li class="level1"><a href="#cc_mqttsn_client_cancel">Cancel Existing Operation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="cc_mqttsn_client_overview"></a>
Overview</h1>
<p>The <b>MQTT-SN Client Library</b> provides simple, asynchronous, non-blocking, and easy to use interface to operate MQTT-SN client. The library doesn't make any assumption on the system it is running on, as well as on the type of I/O link being used to communicate its data to the MQTT-SN gateway.</p>
<p>The main logic of operation can be described as following:</p>
<ul>
<li>Sends and receives over the I/O link are managed outside this library. The data received from the gateway is provided to the library for processing (see <a class="el" href="client_8h.html#ae6ea1adb4c66a841075db0ef4698fe6c" title="Provide data, received over I/O link, to the library for processing.">cc_mqttsn_client_process_data()</a>) and the data to be sent to the gateway is provided by the library using callback (see <a class="el" href="client_8h.html#a167b014ce22fccc1edd54cdbd2074253" title="Set callback to send raw data over I/O link.">cc_mqttsn_client_set_send_output_data_callback()</a>). </li>
<li>The library requires measurement of timeouts, it will request to do so using callback (see <br  />
 <a class="el" href="client_8h.html#ac446655be2f1b1383be39b3ae856381c" title="Set callback to call when time measurement is required.">cc_mqttsn_client_set_next_tick_program_callback()</a>). The driving code will have to use available system timer and notify the library about the requested time expiry (see <a class="el" href="client_8h.html#a3e3d75bdf3dc94b7c70b5e36c8a58bcd" title="Notify client about requested time expiry.">cc_mqttsn_client_tick()</a>). </li>
<li>Sometimes the library will terminate the previously requested time measurement request and inquire the amount of elapsed milliseconds since last request. Such inquiry is performed using callback (see <a class="el" href="client_8h.html#ae0fbeff3de7e87687f19f81a202155d8" title="Set callback to terminate current time measurement.">cc_mqttsn_client_set_cancel_next_tick_wait_callback()</a>). </li>
<li>The library supports only <b>one</b> asynchronous operation at a time. The next one can <b>NOT</b> be started until previous one complete or cancelled. </li>
<li>All the asynchronous operations receive pointer to callback function, which will be invoked when the operation is complete. </li>
<li>When asynchronous operation request receives pointer to any buffer (string or raw data), this buffer must be preserved intact by the caller until the asynchronous operation is complete (provided callback is called).</li>
</ul>
<h1><a class="anchor" id="cc_mqttsn_client_io_links"></a>
Various I/O Links</h1>
<p>MQTT-SN is designed to be a <b>datagram</b> protocol, i.e. if sent message is received by the other side, it is received <b>in full</b> and <b>without errors</b>. If sent over UDP link, it can be used as is. The UDP transport cares about all the rest. However, when sent over other I/O link, such as RS-232 serial connection, the protocol may require additional transport wrapping to insure correct delivery and differentiate between packets.</p>
<p>The interface, this <b>MQTT-SN Client Library</b> provides, allows any sent or received data to be wrapped with or unwrapped from additional independent transport data, that insures safe and correct delivery.</p>
<h1><a class="anchor" id="cc_mqttsn_client_header"></a>
Header</h1>
<p>To use this <b>MQTT-SN Client Library</b> use the following include statement: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cc_mqttsn_client/client.h&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_client_allocation"></a>
Client Allocation</h1>
<p>The library supports may support multiple independent MQTT-SN clients. The allocation of data structures relevant to a single client is performed using <a class="el" href="client_8h.html#ab44b414b65a012d0650b4a7ea2aa912c" title="Allocate new client.">cc_mqttsn_client_new()</a> function. </p><div class="fragment"><div class="line"><a class="code" href="structCC__MqttsnClientHandle.html">CC_MqttsnClientHandle</a> client = <a class="code" href="client_8h.html#ab44b414b65a012d0650b4a7ea2aa912c">cc_mqttsn_client_new</a>();</div>
<div class="ttc" id="aclient_8h_html_ab44b414b65a012d0650b4a7ea2aa912c"><div class="ttname"><a href="client_8h.html#ab44b414b65a012d0650b4a7ea2aa912c">cc_mqttsn_client_new</a></div><div class="ttdeci">CC_MqttsnClientHandle cc_mqttsn_client_new()</div><div class="ttdoc">Allocate new client.</div></div>
<div class="ttc" id="astructCC__MqttsnClientHandle_html"><div class="ttname"><a href="structCC__MqttsnClientHandle.html">CC_MqttsnClientHandle</a></div><div class="ttdoc">Handler used to access client specific data structures.</div><div class="ttdef"><b>Definition:</b> common.h:100</div></div>
</div><!-- fragment --><p> All other functions are client specific, the receive the returned handle as their first parameter.</p>
<p>When work with allocated client is complete, it must be freed using <a class="el" href="client_8h.html#ac2704529f901991b0b14ef363d45f3e3" title="Free previously allocated client.">cc_mqttsn_client_free()</a> function. </p><div class="fragment"><div class="line"><a class="code" href="client_8h.html#ac2704529f901991b0b14ef363d45f3e3">cc_mqttsn_client_free</a>(client);</div>
<div class="ttc" id="aclient_8h_html_ac2704529f901991b0b14ef363d45f3e3"><div class="ttname"><a href="client_8h.html#ac2704529f901991b0b14ef363d45f3e3">cc_mqttsn_client_free</a></div><div class="ttdeci">void cc_mqttsn_client_free(CC_MqttsnClientHandle client)</div><div class="ttdoc">Free previously allocated client.</div></div>
</div><!-- fragment --><p>All the allocated clients are completely independent. It is safe to use multiple threads working with multiple clients as long as there are no concurrent accesses to the same one.</p>
<h1><a class="anchor" id="cc_mqttsn_client_setup"></a>
Client Setup</h1>
<p>As was mentioned earlier, there is a need for multiple callbacks to be set. Four of them are mandatory.</p><ol type="1">
<li>Callback to be invoked when new message needs to be sent to the gateway (see <a class="el" href="client_8h.html#a167b014ce22fccc1edd54cdbd2074253" title="Set callback to send raw data over I/O link.">cc_mqttsn_client_set_send_output_data_callback()</a>). <div class="fragment"><div class="line"><span class="keywordtype">void</span> my_send(<span class="keywordtype">void</span>* userData, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> bufLen, <span class="keywordtype">bool</span> broadcast)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (broadcast) {</div>
<div class="line">        ... <span class="comment">/* broadcast */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        ... <span class="comment">/* send data to connected GW*/</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>* someUserData = ...;</div>
<div class="line"><a class="code" href="client_8h.html#a167b014ce22fccc1edd54cdbd2074253">cc_mqttsn_client_set_send_output_data_callback</a>(client, &amp;my_send, someUserData);</div>
<div class="ttc" id="aclient_8h_html_a167b014ce22fccc1edd54cdbd2074253"><div class="ttname"><a href="client_8h.html#a167b014ce22fccc1edd54cdbd2074253">cc_mqttsn_client_set_send_output_data_callback</a></div><div class="ttdeci">void cc_mqttsn_client_set_send_output_data_callback(CC_MqttsnClientHandle client, CC_MqttsnSendOutputDataFn fn, void *data)</div><div class="ttdoc">Set callback to send raw data over I/O link.</div></div>
</div><!-- fragment --></li>
<li>Callback to be invoked when timer needs to be programmed (see <a class="el" href="client_8h.html#ac446655be2f1b1383be39b3ae856381c" title="Set callback to call when time measurement is required.">cc_mqttsn_client_set_next_tick_program_callback()</a>). <div class="fragment"><div class="line"><span class="keywordtype">void</span> my_timer(<span class="keywordtype">void</span>* userData, <span class="keywordtype">unsigned</span> ms)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* Program asynchronous timer to tick after requested number of milliseconds. When expires invoke cc_mqttsn_client_tick() */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#ac446655be2f1b1383be39b3ae856381c">cc_mqttsn_client_set_next_tick_program_callback</a>(client, &amp;my_timer, someUserData);</div>
<div class="ttc" id="aclient_8h_html_ac446655be2f1b1383be39b3ae856381c"><div class="ttname"><a href="client_8h.html#ac446655be2f1b1383be39b3ae856381c">cc_mqttsn_client_set_next_tick_program_callback</a></div><div class="ttdeci">void cc_mqttsn_client_set_next_tick_program_callback(CC_MqttsnClientHandle client, CC_MqttsnNextTickProgramFn fn, void *data)</div><div class="ttdoc">Set callback to call when time measurement is required.</div></div>
</div><!-- fragment --></li>
<li>Callback to be invoked when previous timer program needs to be cancelled and number of elapsed seconds since last timer programming request known (see <a class="el" href="client_8h.html#ae0fbeff3de7e87687f19f81a202155d8" title="Set callback to terminate current time measurement.">cc_mqttsn_client_set_cancel_next_tick_wait_callback()</a>). <div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> my_cancel_timer(<span class="keywordtype">void</span>* userData)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* cancel timer */</span></div>
<div class="line">    <span class="keywordflow">return</span> ...; <span class="comment">/* return number of elapsed milliseconds */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#ae0fbeff3de7e87687f19f81a202155d8">cc_mqttsn_client_set_cancel_next_tick_wait_callback</a>(client, &amp;my_cancel_timer, someUserData);</div>
<div class="ttc" id="aclient_8h_html_ae0fbeff3de7e87687f19f81a202155d8"><div class="ttname"><a href="client_8h.html#ae0fbeff3de7e87687f19f81a202155d8">cc_mqttsn_client_set_cancel_next_tick_wait_callback</a></div><div class="ttdeci">void cc_mqttsn_client_set_cancel_next_tick_wait_callback(CC_MqttsnClientHandle client, CC_MqttsnCancelNextTickWaitFn fn, void *data)</div><div class="ttdoc">Set callback to terminate current time measurement.</div></div>
</div><!-- fragment --></li>
<li>Callback to be invoked when new application message arrives (see <a class="el" href="client_8h.html#a85da6a26dc64b06844047b7127a61399" title="Set callback to report incoming messages.">cc_mqttsn_client_set_message_report_callback()</a>). <div class="fragment"><div class="line"><span class="keywordtype">void</span> my_message_handler(<span class="keywordtype">void</span>* userData, <span class="keyword">const</span> <a class="code" href="structCC__MqttsnMessageInfo.html">CC_MqttsnMessageInfo</a>* msgInfo)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* handle application message */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#a85da6a26dc64b06844047b7127a61399">cc_mqttsn_client_set_message_report_callback</a>(client, &amp;my_message_handler, someUserData);</div>
<div class="ttc" id="aclient_8h_html_a85da6a26dc64b06844047b7127a61399"><div class="ttname"><a href="client_8h.html#a85da6a26dc64b06844047b7127a61399">cc_mqttsn_client_set_message_report_callback</a></div><div class="ttdeci">void cc_mqttsn_client_set_message_report_callback(CC_MqttsnClientHandle client, CC_MqttsnMessageReportFn fn, void *data)</div><div class="ttdoc">Set callback to report incoming messages.</div></div>
<div class="ttc" id="astructCC__MqttsnMessageInfo_html"><div class="ttname"><a href="structCC__MqttsnMessageInfo.html">CC_MqttsnMessageInfo</a></div><div class="ttdoc">Incoming message information.</div><div class="ttdef"><b>Definition:</b> common.h:119</div></div>
</div><!-- fragment --></li>
</ol>
<p>All other callbacks are optional and described in later sections.</p>
<p>MQTT-SN protocol defines some messages that need to be acknowledged by the gateway. If the expected response is not received after some time, the message needs to be resent. After number of such retry attempts if there is still no response, the requested operation needs to terminate with relevant error code. The retry period in seconds can be configured using <a class="el" href="client_8h.html#a27f3993f68a78f338c5b968f0485d1f5" title="Set retry period to wait between resending unacknowledged message to the gateway.">cc_mqttsn_client_set_retry_period()</a> function and number of retry attempts can be configured using <a class="el" href="client_8h.html#a334c6485a6ef97e87d934d9f72a74b3c" title="Set number of retry attempts to perform before reporting unsuccessful result of the operation.">cc_mqttsn_client_set_retry_count()</a> function. The default values are <b>15</b> seconds and <b>3</b> attempts respectively. </p><div class="fragment"><div class="line"><a class="code" href="client_8h.html#a27f3993f68a78f338c5b968f0485d1f5">cc_mqttsn_client_set_retry_period</a>(client, 5); <span class="comment">// retry after 5 seconds</span></div>
<div class="line"><a class="code" href="client_8h.html#a334c6485a6ef97e87d934d9f72a74b3c">cc_mqttsn_client_set_retry_count</a>(client, 4); <span class="comment">// perform 4 retry attempts</span></div>
<div class="ttc" id="aclient_8h_html_a27f3993f68a78f338c5b968f0485d1f5"><div class="ttname"><a href="client_8h.html#a27f3993f68a78f338c5b968f0485d1f5">cc_mqttsn_client_set_retry_period</a></div><div class="ttdeci">void cc_mqttsn_client_set_retry_period(CC_MqttsnClientHandle client, unsigned value)</div><div class="ttdoc">Set retry period to wait between resending unacknowledged message to the gateway.</div></div>
<div class="ttc" id="aclient_8h_html_a334c6485a6ef97e87d934d9f72a74b3c"><div class="ttname"><a href="client_8h.html#a334c6485a6ef97e87d934d9f72a74b3c">cc_mqttsn_client_set_retry_count</a></div><div class="ttdeci">void cc_mqttsn_client_set_retry_count(CC_MqttsnClientHandle client, unsigned value)</div><div class="ttdoc">Set number of retry attempts to perform before reporting unsuccessful result of the operation.</div></div>
</div><!-- fragment --><p>After client has been successfully configured, it needs to be started. </p><div class="fragment"><div class="line"><a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = <a class="code" href="client_8h.html#aa23423f6249eeb342fcc292ec7bdcf91">cc_mqttsn_client_start</a>(client);</div>
<div class="line"><span class="keywordflow">if</span> (result != <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079faa71957fe69fa1b94d1d0cbc3c7558e1f">CC_MqttsnErrorCode_Success</a>) {</div>
<div class="line">    ... <span class="comment">/* start has failed, probably some mandatory callback hasn&#39;t been set */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_aa23423f6249eeb342fcc292ec7bdcf91"><div class="ttname"><a href="client_8h.html#aa23423f6249eeb342fcc292ec7bdcf91">cc_mqttsn_client_start</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_start(CC_MqttsnClientHandle client)</div><div class="ttdoc">Start the library's operation.</div></div>
<div class="ttc" id="acommon_8h_html_ade7e7c53c5ca30c6134f60607b01079f"><div class="ttname"><a href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a></div><div class="ttdeci">CC_MqttsnErrorCode</div><div class="ttdoc">Error code returned by various API functions.</div><div class="ttdef"><b>Definition:</b> common.h:65</div></div>
<div class="ttc" id="acommon_8h_html_ade7e7c53c5ca30c6134f60607b01079faa71957fe69fa1b94d1d0cbc3c7558e1f"><div class="ttname"><a href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079faa71957fe69fa1b94d1d0cbc3c7558e1f">CC_MqttsnErrorCode_Success</a></div><div class="ttdeci">@ CC_MqttsnErrorCode_Success</div><div class="ttdoc">The requested operation was successfully started.</div><div class="ttdef"><b>Definition:</b> common.h:66</div></div>
</div><!-- fragment --><p> If a gateway needs to be discovered (see <a class="el" href="index.html#cc_mqttsn_client_gateways">Gateway Discovery</a>), the client will immediately request to send generated <b>SEARCHGW</b> message.</p>
<p>If client's work needs to be paused for a while, it can be stopped using <a class="el" href="client_8h.html#a51abc115c611a9258c44a75661094c6d" title="Stop the library&#39;s operation.">cc_mqttsn_client_stop()</a> and restarted again using <a class="el" href="client_8h.html#aa23423f6249eeb342fcc292ec7bdcf91" title="Start the library&#39;s operation.">cc_mqttsn_client_start()</a>.</p>
<h1><a class="anchor" id="cc_mqttsn_client_data_recv"></a>
Receiving Data</h1>
<p>When new data datagram is successfully received over I/O link, it needs to be passed to the library for processing using <a class="el" href="client_8h.html#ae6ea1adb4c66a841075db0ef4698fe6c" title="Provide data, received over I/O link, to the library for processing.">cc_mqttsn_client_process_data()</a>. </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[1024] = {0};</div>
<div class="line">... <span class="comment">/* Read data into buffer */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> consumed = <a class="code" href="client_8h.html#ae6ea1adb4c66a841075db0ef4698fe6c">cc_mqttsn_client_process_data</a>(client, &amp;buf[0], bytesCount);</div>
<div class="line"><span class="keywordflow">if</span> (consumed &lt; bytesCount) {</div>
<div class="line">    ... <span class="comment">/* Unexpected protocol error, too few bytes consumed. */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_ae6ea1adb4c66a841075db0ef4698fe6c"><div class="ttname"><a href="client_8h.html#ae6ea1adb4c66a841075db0ef4698fe6c">cc_mqttsn_client_process_data</a></div><div class="ttdeci">unsigned cc_mqttsn_client_process_data(CC_MqttsnClientHandle client, const unsigned char *buf, unsigned bufLen)</div><div class="ttdoc">Provide data, received over I/O link, to the library for processing.</div></div>
</div><!-- fragment --><p> The <a class="el" href="client_8h.html#ae6ea1adb4c66a841075db0ef4698fe6c" title="Provide data, received over I/O link, to the library for processing.">cc_mqttsn_client_process_data()</a> function returns number of bytes that were actually processed. If number of processed bytes is less that number of bytes residing in the buffer, then probably some unexpected protocol error has occurred.</p>
<p>The invocation of <a class="el" href="client_8h.html#ae6ea1adb4c66a841075db0ef4698fe6c" title="Provide data, received over I/O link, to the library for processing.">cc_mqttsn_client_process_data()</a> function may cause invocation of multiple callbacks, such as cancellation of the current time measurement, report of incoming new application message, report information about new gateway, asynchronous operation completion, request to send data back to the gateway, and reprogram timer with new delay value.</p>
<h1><a class="anchor" id="cc_mqttsn_client_data_send"></a>
Sending Data</h1>
<p>As was mentioned earlier, the request to send data is performed using callback function. It is set using <a class="el" href="client_8h.html#a167b014ce22fccc1edd54cdbd2074253" title="Set callback to send raw data over I/O link.">cc_mqttsn_client_set_send_output_data_callback()</a>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_send(<span class="keywordtype">void</span>* userData, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> bufLen, <span class="keywordtype">bool</span> broadcast)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#a167b014ce22fccc1edd54cdbd2074253">cc_mqttsn_client_set_send_output_data_callback</a>(client, &amp;my_send, someUserData);</div>
</div><!-- fragment --><p> <b>NOTE</b>, that the callback function receives pointer to the buffer of data. This buffer will be destroyed or updated right after the function returns. The callback code may require to copy the buffer contents to some other private data structure and preserve it until data has been properly sent over the I/O link in full.</p>
<p>Also <b>NOTE</b> the <b>broadcast</b> boolean parameter. It specifies whether the data needs to be broadcasted on the network or sent directly to the gateway that the client is connected to.</p>
<h1><a class="anchor" id="cc_mqttsn_client_time_measurement"></a>
Time Measurement</h1>
<p>The MQTT-SN client must be aware of time to be able to measure delays between messages. The driving code has to provide a callback using which the library may request for such time measurement. The second parameter to the callback will specify number of <b>milliseconds</b> it needs to measure. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_timer(<span class="keywordtype">void</span>* userData, <span class="keywordtype">unsigned</span> ms)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* Program asynchronous timer to tick after requested number of milliseconds. When expires invoke cc_mqttsn_client_tick() */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#ac446655be2f1b1383be39b3ae856381c">cc_mqttsn_client_set_next_tick_program_callback</a>(client, &amp;my_timer, someUserData);</div>
</div><!-- fragment --><p>The driving code will have to use its system timer(s) to measure the required time, and notify the library when it expires using <a class="el" href="client_8h.html#a3e3d75bdf3dc94b7c70b5e36c8a58bcd" title="Notify client about requested time expiry.">cc_mqttsn_client_tick()</a> function. </p><div class="fragment"><div class="line"><a class="code" href="client_8h.html#a3e3d75bdf3dc94b7c70b5e36c8a58bcd">cc_mqttsn_client_tick</a>(client);</div>
<div class="ttc" id="aclient_8h_html_a3e3d75bdf3dc94b7c70b5e36c8a58bcd"><div class="ttname"><a href="client_8h.html#a3e3d75bdf3dc94b7c70b5e36c8a58bcd">cc_mqttsn_client_tick</a></div><div class="ttdeci">void cc_mqttsn_client_tick(CC_MqttsnClientHandle client)</div><div class="ttdoc">Notify client about requested time expiry.</div></div>
</div><!-- fragment --><p>Based on some events, the library may require knowledge of elapsed time since last tick programming request. For this purpose the driving code must set a callback to cancel the existing time measurement and return number of elapsed <b>milliseconds</b>. </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> my_cancel_timer(<span class="keywordtype">void</span>* userData)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* cancel timer */</span></div>
<div class="line">    <span class="keywordflow">return</span> ...; <span class="comment">/* return number of elapsed milliseconds */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#ae0fbeff3de7e87687f19f81a202155d8">cc_mqttsn_client_set_cancel_next_tick_wait_callback</a>(client, &amp;my_cancel_timer, someUserData);</div>
</div><!-- fragment --><p> When the library issues the existing time measurement cancellation request, the driving code must cancel its programmed system timer and must <b>NOT</b> call <a class="el" href="client_8h.html#a3e3d75bdf3dc94b7c70b5e36c8a58bcd" title="Notify client about requested time expiry.">cc_mqttsn_client_tick()</a> function later on.</p>
<h1><a class="anchor" id="cc_mqttsn_client_gateways"></a>
Gateway Discovery</h1>
<p>The MQTT-SN protocol built to be suitable for wireless sensor networks, where the exact address of the gateway may be unknown upfront or there may be multiple gateways available. As the result it includes messages for gateway tracking and discovery. However, when the address of the gateway to use is known, the gateway discovery may become unnecessary. The <b>MQTT-SN Client Library</b> provides an ability to enable or disable broadcast of <b>SEARCHGW</b> message, which causes available gateways to respond and be identified. </p><div class="fragment"><div class="line"><a class="code" href="client_8h.html#a0cc7d79aa66d9efb3f335911152e6500">cc_mqttsn_client_set_searchgw_enabled</a>(client, <span class="keyword">false</span>); <span class="comment">/* Disable sending of SEARCHGW messages to discover the gateway */</span></div>
<div class="ttc" id="aclient_8h_html_a0cc7d79aa66d9efb3f335911152e6500"><div class="ttname"><a href="client_8h.html#a0cc7d79aa66d9efb3f335911152e6500">cc_mqttsn_client_set_searchgw_enabled</a></div><div class="ttdeci">void cc_mqttsn_client_set_searchgw_enabled(CC_MqttsnClientHandle client, bool value)</div><div class="ttdoc">Enable/Disable search for gateways.</div></div>
</div><!-- fragment --><p> By default, the broadcast of <b>SEARCHGW</b> message is <b>enabled</b>, and the library will immediately request to do so when call to <a class="el" href="client_8h.html#aa23423f6249eeb342fcc292ec7bdcf91" title="Start the library&#39;s operation.">cc_mqttsn_client_start()</a> is performed.</p>
<p>The library monitors the <b>GWINFO</b> responses of the gateways as well as their own independent advertising of their presence (using <b>ADVERTISE</b> message) and reports the discovered gateways via callback. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_gw_status_report(<span class="keywordtype">void</span>* userData, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> gwId, <a class="code" href="common_8h.html#a55fac5d32cd1c5ab28bd9f4866410f2f">CC_MqttsnGwStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="common_8h.html#a55fac5d32cd1c5ab28bd9f4866410f2fadf544f048bb97440a0aebf749111267d">CC_MqttsnGwStatus_Available</a>) {</div>
<div class="line">        ... <span class="comment">/* New gateway has been discovered */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status == <a class="code" href="common_8h.html#a55fac5d32cd1c5ab28bd9f4866410f2fad48125edb3b63bd1d42d4079dd54c0e1">CC_MqttsnGwStatus_TimedOut</a>) {</div>
<div class="line">        ... <span class="comment">/* The gateway hasn&#39;t advertise its presence for a while, probably is not available any more */</span></div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#ad08030e56cb8639b25031b957d2cc72e">cc_mqttsn_client_set_gw_status_report_callback</a>(client, &amp;my_gw_status_report, someUserData);</div>
<div class="ttc" id="aclient_8h_html_ad08030e56cb8639b25031b957d2cc72e"><div class="ttname"><a href="client_8h.html#ad08030e56cb8639b25031b957d2cc72e">cc_mqttsn_client_set_gw_status_report_callback</a></div><div class="ttdeci">void cc_mqttsn_client_set_gw_status_report_callback(CC_MqttsnClientHandle client, CC_MqttsnGwStatusReportFn fn, void *data)</div><div class="ttdoc">Set callback to report status of the gateway.</div></div>
<div class="ttc" id="acommon_8h_html_a55fac5d32cd1c5ab28bd9f4866410f2f"><div class="ttname"><a href="common_8h.html#a55fac5d32cd1c5ab28bd9f4866410f2f">CC_MqttsnGwStatus</a></div><div class="ttdeci">CC_MqttsnGwStatus</div><div class="ttdoc">Status of the gateway.</div><div class="ttdef"><b>Definition:</b> common.h:78</div></div>
<div class="ttc" id="acommon_8h_html_a55fac5d32cd1c5ab28bd9f4866410f2fad48125edb3b63bd1d42d4079dd54c0e1"><div class="ttname"><a href="common_8h.html#a55fac5d32cd1c5ab28bd9f4866410f2fad48125edb3b63bd1d42d4079dd54c0e1">CC_MqttsnGwStatus_TimedOut</a></div><div class="ttdeci">@ CC_MqttsnGwStatus_TimedOut</div><div class="ttdoc">The gateway hasn't advertised its presence in time, assumed disconnected.</div><div class="ttdef"><b>Definition:</b> common.h:81</div></div>
<div class="ttc" id="acommon_8h_html_a55fac5d32cd1c5ab28bd9f4866410f2fadf544f048bb97440a0aebf749111267d"><div class="ttname"><a href="common_8h.html#a55fac5d32cd1c5ab28bd9f4866410f2fadf544f048bb97440a0aebf749111267d">CC_MqttsnGwStatus_Available</a></div><div class="ttdeci">@ CC_MqttsnGwStatus_Available</div><div class="ttdoc">The gateway is available.</div><div class="ttdef"><b>Definition:</b> common.h:80</div></div>
</div><!-- fragment --><p> The gateways report their numeric ID (only one byte long), which is expected be unique on the available network. This ID is passed as a parameter to the provided callback. However, in order to connect to the chosen available gateway, there may be a need to know address of the latter. In this case, the driving code should store the origin address of every message in its private data structures prior to forwarding the incoming data to the library for processing (see <a class="el" href="index.html#cc_mqttsn_client_data_recv">Receiving Data</a>). If the gateway status report callback is called immediately, indicating available gateway, the reported ID as well as recorded address may be stored as gateway identification information and to be used for connection in the future.</p>
<p><b>NOTE</b>, that the library sends <b>SEARCHGW</b> messages only when there is no known available gateway. It will continue to send them periodically until first available gateway responds. After that, the library will count on any new gateways to independently advertise their presence using <b>ADVERTISE</b> message, when they become available. When the last known gateway fails to re-advertise its presence after some time, the library will resume sending <b>SEARCHGW</b> messages again until first gateway responds.</p>
<p>Also <b>NOTE</b>, that the reported list of available gateways is indicative only. There may be the case when some gateway gone offline, but the library hasn't reported that it's missing yet. The opposite case may also take place, when some gateway failed to advertise its presence in time, and hence was reported as "timed out", but may still be online and respond to messages. The only way to identify the real availability of the gateway is to try to connect to it (see <a class="el" href="index.html#cc_mqttsn_client_connect_disconnect">Connect / Disconnect</a> section below).</p>
<p>The library provides an ability to discard information about currently being tracked gateway. It may be useful when attempt to connect or send any messages fails with timeout, which may indicate that gateway has gone offline. When the gateway appears online again and advertises its presence, the gateway status report callback will be invoked again reporting new availability. </p><div class="fragment"><div class="line"><a class="code" href="client_8h.html#ae19d0e5712af864c49c6def706c96687">cc_mqttsn_client_discard_gw</a>(client, gwId);</div>
<div class="ttc" id="aclient_8h_html_ae19d0e5712af864c49c6def706c96687"><div class="ttname"><a href="client_8h.html#ae19d0e5712af864c49c6def706c96687">cc_mqttsn_client_discard_gw</a></div><div class="ttdeci">void cc_mqttsn_client_discard_gw(CC_MqttsnClientHandle client, unsigned char gwId)</div><div class="ttdoc">Discard information about the gateway.</div></div>
</div><!-- fragment --><p>The library also provides an ability to discard information about all gateways at once. </p><div class="fragment"><div class="line"><a class="code" href="client_8h.html#ae1da563f4d08a0a25fb02eea9c0fd7d0">cc_mqttsn_client_discard_all_gw</a>(client);</div>
<div class="ttc" id="aclient_8h_html_ae1da563f4d08a0a25fb02eea9c0fd7d0"><div class="ttname"><a href="client_8h.html#ae1da563f4d08a0a25fb02eea9c0fd7d0">cc_mqttsn_client_discard_all_gw</a></div><div class="ttdeci">void cc_mqttsn_client_discard_all_gw(CC_MqttsnClientHandle client)</div><div class="ttdoc">Discard information about all gateways.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_client_connect_disconnect"></a>
Connect / Disconnect</h1>
<p>In order to establish connection to MQTT-SN gateway, the client must send to it special <b>CONNECT</b> message. It must be done prior to issuing any publish or subscribe request. The connection can be performed using <a class="el" href="client_8h.html#a2080f606cdad958c4715f55f296b54b0" title="Issue the connect request to the gateway.">cc_mqttsn_client_connect()</a> call. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* clientId = <span class="stringliteral">&quot;my_client_id&quot;</span>;</div>
<div class="line"><span class="keywordtype">void</span> my_connect_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55faa6c651fcaed12bd74b501c4e32aa09fc">CC_MqttsnAsyncOpStatus_Successful</a>) {</div>
<div class="line">        ... <span class="comment">/* Connection is successful, do something */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        ... <span class="comment">/* process error statuses */</span></div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> someFunc()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = <a class="code" href="client_8h.html#a2080f606cdad958c4715f55f296b54b0">cc_mqttsn_client_connect</a>(client, clientId, 60, <span class="keyword">true</span>, NULL, &amp;my_client_connect, someUserData);</div>
<div class="line">    ... </div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_a2080f606cdad958c4715f55f296b54b0"><div class="ttname"><a href="client_8h.html#a2080f606cdad958c4715f55f296b54b0">cc_mqttsn_client_connect</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_connect(CC_MqttsnClientHandle client, const char *clientId, unsigned short keepAliveSeconds, bool cleanSession, const CC_MqttsnWillInfo *willInfo, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Issue the connect request to the gateway.</div></div>
<div class="ttc" id="acommon_8h_html_ab0af1cb13f466184b8ecc4b1a86ec55f"><div class="ttname"><a href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a></div><div class="ttdeci">CC_MqttsnAsyncOpStatus</div><div class="ttdoc">Status of the asynchronous operation.</div><div class="ttdef"><b>Definition:</b> common.h:87</div></div>
<div class="ttc" id="acommon_8h_html_ab0af1cb13f466184b8ecc4b1a86ec55faa6c651fcaed12bd74b501c4e32aa09fc"><div class="ttname"><a href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55faa6c651fcaed12bd74b501c4e32aa09fc">CC_MqttsnAsyncOpStatus_Successful</a></div><div class="ttdeci">@ CC_MqttsnAsyncOpStatus_Successful</div><div class="ttdoc">The operation was successful.</div><div class="ttdef"><b>Definition:</b> common.h:89</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that client ID (second parameter) can be NULL or empty string. In this case, the <b>CONNECT</b> message is sent to the gateway with empty client ID information. The gateway will either replace it with some other default ID (based on its configuration), or forward the connection request to broker with empty client ID to make it an anonymous client.</p>
<p>Also <b>NOTE</b>, that <b>will</b> information (fifth parameter) may also be NULL to indicate that will doesn't exist. NULL or empty string as topic in the passed <a class="el" href="structCC__MqttsnWillInfo.html">CC_MqttsnWillInfo</a> structure will have the same effect. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* willTopic = <span class="stringliteral">&quot;this/is/will/topic&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> willMsg[] = {...}</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> willMsgSize = <span class="keyword">sizeof</span>(willMsg)/<span class="keyword">sizeof</span>(willMsg[0]);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> someFunc()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structCC__MqttsnWillInfo.html">CC_MqttsnWillInfo</a> willInfo;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#a9ec4c6f595c867ed54553acd5bf8ac16">topic</a> = willTopic;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#a393e194ac3aee48ef8d535692f5d68fc">msg</a> = willMsg;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#af55fc0e141e96f293c5ce5768b70fd68">msgLen</a> = willMsgSize;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#acac490d66a4fe2969798d187bc2c5776">qos</a> = <a class="code" href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a4f08dfa2b15c80f54bc722a1c4aee136">CC_MqttsnQoS_AtMostOnceDelivery</a>;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#a62a9f84effbd4561c9bee4a7eea46d3d">retain</a> = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = <a class="code" href="client_8h.html#a2080f606cdad958c4715f55f296b54b0">cc_mqttsn_client_connect</a>(client, clientId, 60, <span class="keyword">true</span>, &amp;willInfo, &amp;my_client_connect, someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="acommon_8h_html_adf1bd91b9b557d00ba1d2fbd604151a6a4f08dfa2b15c80f54bc722a1c4aee136"><div class="ttname"><a href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a4f08dfa2b15c80f54bc722a1c4aee136">CC_MqttsnQoS_AtMostOnceDelivery</a></div><div class="ttdeci">@ CC_MqttsnQoS_AtMostOnceDelivery</div><div class="ttdoc">QoS=0. At most once delivery.</div><div class="ttdef"><b>Definition:</b> common.h:58</div></div>
<div class="ttc" id="astructCC__MqttsnWillInfo_html"><div class="ttname"><a href="structCC__MqttsnWillInfo.html">CC_MqttsnWillInfo</a></div><div class="ttdoc">Will Information.</div><div class="ttdef"><b>Definition:</b> common.h:109</div></div>
<div class="ttc" id="astructCC__MqttsnWillInfo_html_a393e194ac3aee48ef8d535692f5d68fc"><div class="ttname"><a href="structCC__MqttsnWillInfo.html#a393e194ac3aee48ef8d535692f5d68fc">CC_MqttsnWillInfo::msg</a></div><div class="ttdeci">const unsigned char * msg</div><div class="ttdoc">Pointer to the buffer containing will binary message.</div><div class="ttdef"><b>Definition:</b> common.h:111</div></div>
<div class="ttc" id="astructCC__MqttsnWillInfo_html_a62a9f84effbd4561c9bee4a7eea46d3d"><div class="ttname"><a href="structCC__MqttsnWillInfo.html#a62a9f84effbd4561c9bee4a7eea46d3d">CC_MqttsnWillInfo::retain</a></div><div class="ttdeci">bool retain</div><div class="ttdoc">Retain flag.</div><div class="ttdef"><b>Definition:</b> common.h:114</div></div>
<div class="ttc" id="astructCC__MqttsnWillInfo_html_a9ec4c6f595c867ed54553acd5bf8ac16"><div class="ttname"><a href="structCC__MqttsnWillInfo.html#a9ec4c6f595c867ed54553acd5bf8ac16">CC_MqttsnWillInfo::topic</a></div><div class="ttdeci">const char * topic</div><div class="ttdoc">Topic of the will, can be NULL (means empty topic)</div><div class="ttdef"><b>Definition:</b> common.h:110</div></div>
<div class="ttc" id="astructCC__MqttsnWillInfo_html_acac490d66a4fe2969798d187bc2c5776"><div class="ttname"><a href="structCC__MqttsnWillInfo.html#acac490d66a4fe2969798d187bc2c5776">CC_MqttsnWillInfo::qos</a></div><div class="ttdeci">CC_MqttsnQoS qos</div><div class="ttdoc">QoS level of the will message.</div><div class="ttdef"><b>Definition:</b> common.h:113</div></div>
<div class="ttc" id="astructCC__MqttsnWillInfo_html_af55fc0e141e96f293c5ce5768b70fd68"><div class="ttname"><a href="structCC__MqttsnWillInfo.html#af55fc0e141e96f293c5ce5768b70fd68">CC_MqttsnWillInfo::msgLen</a></div><div class="ttdeci">unsigned msgLen</div><div class="ttdoc">Length of the buffer containing will binary message.</div><div class="ttdef"><b>Definition:</b> common.h:112</div></div>
</div><!-- fragment --><p> Plaese <b>pay attention</b> to the fact that all the buffers containing client ID, will topic as will as will message body must be preserved intact until the completion callback is called. However, the <b>willInfo</b> structure may reside on the stack and be destroyed right after invocation of <a class="el" href="client_8h.html#a2080f606cdad958c4715f55f296b54b0" title="Issue the connect request to the gateway.">cc_mqttsn_client_connect()</a> function.</p>
<p>When client needs to gracefully terminate its connection to the gateway it needs to send <b>DISCONNECT</b> message. It can be achieved by calling to <a class="el" href="client_8h.html#ad026c467c20242b443567d41846344cc" title="Disconnect from the gateway.">cc_mqttsn_client_disconnect()</a> function. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_disconnect_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* do something */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = <a class="code" href="client_8h.html#ad026c467c20242b443567d41846344cc">cc_mqttsn_client_disconnect</a>(client, &amp;my_disconnect_complete, someUserData);</div>
<div class="line">...</div>
<div class="ttc" id="aclient_8h_html_ad026c467c20242b443567d41846344cc"><div class="ttname"><a href="client_8h.html#ad026c467c20242b443567d41846344cc">cc_mqttsn_client_disconnect</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_disconnect(CC_MqttsnClientHandle client, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Disconnect from the gateway.</div></div>
</div><!-- fragment --><p> If client just abandons its connection to the gateway without proper disconnection, sooner or later, the broker will terminate its connection to the client through gateway and will publish the client's will (if such existed).</p>
<p>Regardless of success/failure status reported to the callback, the library assumes disconnected state and won't be able to execute operations that require valid connection to the gateway.</p>
<p>The gateway itself may issue unsolicited disconnection request. To get notified of such requests, the client needs to set a special callback. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_gw_disconnect_report(<span class="keywordtype">void</span>* userData)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* try to connect to the gateway again */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="client_8h.html#a8c0bf8a3d887506b95d724430fa01a2a">cc_mqttsn_client_set_gw_disconnect_report_callback</a>(client, &amp;my_gw_disconnect_report, someUserData);</div>
<div class="ttc" id="aclient_8h_html_a8c0bf8a3d887506b95d724430fa01a2a"><div class="ttname"><a href="client_8h.html#a8c0bf8a3d887506b95d724430fa01a2a">cc_mqttsn_client_set_gw_disconnect_report_callback</a></div><div class="ttdeci">void cc_mqttsn_client_set_gw_disconnect_report_callback(CC_MqttsnClientHandle client, CC_MqttsnGwDisconnectReportFn fn, void *data)</div><div class="ttdoc">Set callback to report unsolicited disconnection of the gateway.</div></div>
</div><!-- fragment --><p> If this callback is invoked, the client may try to connect to the gateway again.</p>
<p>When establishing first connection to the broker (using <a class="el" href="client_8h.html#a2080f606cdad958c4715f55f296b54b0" title="Issue the connect request to the gateway.">cc_mqttsn_client_connect()</a>), the client ID and "keep alive" period information is provided. This information is stored in internal data structures of the library. When there is a need to refresh the same connection to the client, <a class="el" href="client_8h.html#ad507e60e9274c03ff1ae0a0952097c27" title="Reconnect to the gateway using previously used client ID and keep alive period.">cc_mqttsn_client_reconnect()</a> function may be used. Such need may arise when any asynchronous operation reports <a class="el" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55fa816b6f2a2f298318a09dd06e00e0b2fb">CC_MqttsnAsyncOpStatus_NoResponse</a>. It may happen for multiple reasons, for example, when gateway issued unsolicited disconnect request, but its <b>DISCONNECT</b> message wasn't received by the client. The gateway will drop or reject any incoming messages until the new connection request is sent. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_reconnect_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55faa6c651fcaed12bd74b501c4e32aa09fc">CC_MqttsnAsyncOpStatus_Successful</a>) {</div>
<div class="line">        ... <span class="comment">/* Connection is successful, do something */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        ... <span class="comment">/* process error statuses */</span></div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = <a class="code" href="client_8h.html#ad507e60e9274c03ff1ae0a0952097c27">cc_mqttsn_client_reconnect</a>(client, &amp;my_reconnect_complete, someUserData);</div>
<div class="line">...</div>
<div class="ttc" id="aclient_8h_html_ad507e60e9274c03ff1ae0a0952097c27"><div class="ttname"><a href="client_8h.html#ad507e60e9274c03ff1ae0a0952097c27">cc_mqttsn_client_reconnect</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_reconnect(CC_MqttsnClientHandle client, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Reconnect to the gateway using previously used client ID and keep alive period.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_client_publish"></a>
Publishing</h1>
<p>The publish operation is performed using <a class="el" href="client_8h.html#ad5ddb7e98a7542ff2a448cd054e7a88f" title="Publish message with topic string.">cc_mqttsn_client_publish()</a> function call. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_publish_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    ...    </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* pubTopic = <span class="stringliteral">&quot;some/topic&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pubData[] = {...};</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> pubDataSize = <span class="keyword">sizeof</span>(pubData)/<span class="keyword">sizeof</span>(pubData[0]);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> someFunc() {</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = </div>
<div class="line">        <a class="code" href="client_8h.html#ad5ddb7e98a7542ff2a448cd054e7a88f">cc_mqttsn_client_publish</a>(</div>
<div class="line">            client, </div>
<div class="line">            pubTopic,</div>
<div class="line">            pubData,</div>
<div class="line">            pubDataSize,</div>
<div class="line">            <a class="code" href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a8dc40fd2f13529b8de350e37666b453b">CC_MqttsnQoS_AtLeastOnceDelivery</a>,</div>
<div class="line">            <span class="keyword">false</span>,</div>
<div class="line">            &amp;my_publish_complete,</div>
<div class="line">            someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_ad5ddb7e98a7542ff2a448cd054e7a88f"><div class="ttname"><a href="client_8h.html#ad5ddb7e98a7542ff2a448cd054e7a88f">cc_mqttsn_client_publish</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_publish(CC_MqttsnClientHandle client, const char *topic, const unsigned char *msg, unsigned msgLen, CC_MqttsnQoS qos, bool retain, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Publish message with topic string.</div></div>
<div class="ttc" id="acommon_8h_html_adf1bd91b9b557d00ba1d2fbd604151a6a8dc40fd2f13529b8de350e37666b453b"><div class="ttname"><a href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a8dc40fd2f13529b8de350e37666b453b">CC_MqttsnQoS_AtLeastOnceDelivery</a></div><div class="ttdeci">@ CC_MqttsnQoS_AtLeastOnceDelivery</div><div class="ttdoc">QoS=1. At least once delivery.</div><div class="ttdef"><b>Definition:</b> common.h:59</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that buffers of publish topic and publish message data must be preserved intact by the caller until the completion callback is invoked.</p>
<p>The MQTT-SN protocol also supports predefined numeric topic IDs instead of topic strings. To publish such message use <a class="el" href="client_8h.html#ae72767c8f3ab2e5841bd1f450979a922" title="Publish message with predefined topic ID.">cc_mqttsn_client_publish_id()</a>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunc() {</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = </div>
<div class="line">        <a class="code" href="client_8h.html#ae72767c8f3ab2e5841bd1f450979a922">cc_mqttsn_client_publish_id</a>(</div>
<div class="line">            client, </div>
<div class="line">            pubTopicId, <span class="comment">/* numeric topic ID instead of string */</span></div>
<div class="line">            pubData,</div>
<div class="line">            pubDataSize,</div>
<div class="line">            <a class="code" href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a8dc40fd2f13529b8de350e37666b453b">CC_MqttsnQoS_AtLeastOnceDelivery</a>,</div>
<div class="line">            <span class="keyword">false</span>,</div>
<div class="line">            &amp;my_publish_complete,</div>
<div class="line">            someUserData);</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_ae72767c8f3ab2e5841bd1f450979a922"><div class="ttname"><a href="client_8h.html#ae72767c8f3ab2e5841bd1f450979a922">cc_mqttsn_client_publish_id</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_publish_id(CC_MqttsnClientHandle client, CC_MqttsnTopicId topicId, const unsigned char *msg, unsigned msgLen, CC_MqttsnQoS qos, bool retain, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Publish message with predefined topic ID.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_client_subscribe"></a>
Subscribing</h1>
<p>The subscribe operation is performed using <a class="el" href="client_8h.html#abac7ec5fcddfc9835582e024ba10d1f0" title="Subscribe to topic.">cc_mqttsn_client_subscribe()</a> function call. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_subscribe_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status, <a class="code" href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6">CC_MqttsnQoS</a> qos)</div>
<div class="line">{</div>
<div class="line">    ...    </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* subTopic = <span class="stringliteral">&quot;subtopic1/+/subtopic2/#&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> someFunc() {</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = </div>
<div class="line">        <a class="code" href="client_8h.html#abac7ec5fcddfc9835582e024ba10d1f0">cc_mqttsn_client_subscribe</a>(</div>
<div class="line">            client, </div>
<div class="line">            subTopic,</div>
<div class="line">            <a class="code" href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a768097d6c1c08cc69b85848c28db31f5">CC_MqttsnQoS_ExactlyOnceDelivery</a>, <span class="comment">/* max QoS */</span></div>
<div class="line">            &amp;my_subscribe_complete,</div>
<div class="line">            someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_abac7ec5fcddfc9835582e024ba10d1f0"><div class="ttname"><a href="client_8h.html#abac7ec5fcddfc9835582e024ba10d1f0">cc_mqttsn_client_subscribe</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_subscribe(CC_MqttsnClientHandle client, const char *topic, CC_MqttsnQoS qos, CC_MqttsnSubscribeCompleteReportFn callback, void *data)</div><div class="ttdoc">Subscribe to topic.</div></div>
<div class="ttc" id="acommon_8h_html_adf1bd91b9b557d00ba1d2fbd604151a6"><div class="ttname"><a href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6">CC_MqttsnQoS</a></div><div class="ttdeci">CC_MqttsnQoS</div><div class="ttdoc">Quality of Service.</div><div class="ttdef"><b>Definition:</b> common.h:56</div></div>
<div class="ttc" id="acommon_8h_html_adf1bd91b9b557d00ba1d2fbd604151a6a768097d6c1c08cc69b85848c28db31f5"><div class="ttname"><a href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a768097d6c1c08cc69b85848c28db31f5">CC_MqttsnQoS_ExactlyOnceDelivery</a></div><div class="ttdeci">@ CC_MqttsnQoS_ExactlyOnceDelivery</div><div class="ttdoc">QoS=2. Exactly once delivery.</div><div class="ttdef"><b>Definition:</b> common.h:60</div></div>
</div><!-- fragment --><p> Please pay closer attention to the following facts: </p><ul>
<li>The buffer containing subscription topic must be preserved intact by the caller until the end of the operation when callback is called. </li>
<li>The <b>qos</b> parameter to the function call specifies <b>maximal</b> quality of service level, with which the gateway/broker is allowed to publish messages to the client. </li>
<li>The completion callback also has <b>qos</b> parameter. It specifies <b>actual</b> maximal QoS level the broker/gateway is going to use to publish messages to the client. </li>
<li>Just like with MQTT protocol, the subscription topic may have the same <b>+</b> and <b>#</b> wildcards.</li>
</ul>
<p>The MQTT-SN protocol also supports subscription to predefined topic IDs instead of topic strings. To do so use <a class="el" href="client_8h.html#a4b8419d25e72fcc2a196ade23057ca59" title="Subscribe to topic having predefined topic ID.">cc_mqttsn_client_subscribe_id()</a>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunc() {</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = </div>
<div class="line">        <a class="code" href="client_8h.html#a4b8419d25e72fcc2a196ade23057ca59">cc_mqttsn_client_subscribe_id</a>(</div>
<div class="line">            client, </div>
<div class="line">            subTopicId, <span class="comment">/* numeric topic ID instead of string */</span></div>
<div class="line">            <a class="code" href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a768097d6c1c08cc69b85848c28db31f5">CC_MqttsnQoS_ExactlyOnceDelivery</a>,</div>
<div class="line">            &amp;my_subscribe_complete,</div>
<div class="line">            someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_a4b8419d25e72fcc2a196ade23057ca59"><div class="ttname"><a href="client_8h.html#a4b8419d25e72fcc2a196ade23057ca59">cc_mqttsn_client_subscribe_id</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_subscribe_id(CC_MqttsnClientHandle client, CC_MqttsnTopicId topicId, CC_MqttsnQoS qos, CC_MqttsnSubscribeCompleteReportFn callback, void *data)</div><div class="ttdoc">Subscribe to topic having predefined topic ID.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_client_unsubscribe"></a>
Unsubscribing</h1>
<p>To unsubscribe use either <a class="el" href="client_8h.html#a950b255ceedeeeadfb4f9e22478ab750" title="Unsubscribe from messages having specified topic.">cc_mqttsn_client_unsubscribe()</a> for string topics: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_unsubscribe_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    ...    </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* unsubTopic = <span class="stringliteral">&quot;some/topic&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> someFunc() {</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = </div>
<div class="line">        <a class="code" href="client_8h.html#a950b255ceedeeeadfb4f9e22478ab750">cc_mqttsn_client_unsubscribe</a>(</div>
<div class="line">            client, </div>
<div class="line">            unsubTopic,</div>
<div class="line">            &amp;my_unsubscribe_complete,</div>
<div class="line">            someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_a950b255ceedeeeadfb4f9e22478ab750"><div class="ttname"><a href="client_8h.html#a950b255ceedeeeadfb4f9e22478ab750">cc_mqttsn_client_unsubscribe</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_unsubscribe(CC_MqttsnClientHandle client, const char *topic, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Unsubscribe from messages having specified topic.</div></div>
</div><!-- fragment --><p> and <a class="el" href="client_8h.html#a9c41f39e6546ace4bd31480554f5f2ea" title="Unsubscribe from messages having predefined topic ID.">cc_mqttsn_client_unsubscribe_id()</a> for predefined numeric topic IDs: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> someFunc() {</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = </div>
<div class="line">        <a class="code" href="client_8h.html#a9c41f39e6546ace4bd31480554f5f2ea">cc_mqttsn_client_unsubscribe_id</a>(</div>
<div class="line">            client, </div>
<div class="line">            unsubTopicId, <span class="comment">// numeric ID</span></div>
<div class="line">            &amp;my_unsubscribe_complete,</div>
<div class="line">            someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_a9c41f39e6546ace4bd31480554f5f2ea"><div class="ttname"><a href="client_8h.html#a9c41f39e6546ace4bd31480554f5f2ea">cc_mqttsn_client_unsubscribe_id</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_unsubscribe_id(CC_MqttsnClientHandle client, CC_MqttsnTopicId topicId, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Unsubscribe from messages having predefined topic ID.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_client_will"></a>
Updating the Will</h1>
<p>There are several ways to update the will information that was initially setup during connection process (see <a class="el" href="index.html#cc_mqttsn_client_connect_disconnect">Connect / Disconnect</a>).</p>
<p>One way is to update both topic and message body in one go: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_will_update_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* willTopic = <span class="stringliteral">&quot;updated/will/topic&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> willMsg[] = {...}</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> willMsgSize = <span class="keyword">sizeof</span>(willMsg)/<span class="keyword">sizeof</span>(willMsg[0]);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> someFunc()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structCC__MqttsnWillInfo.html">CC_MqttsnWillInfo</a> willInfo;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#a9ec4c6f595c867ed54553acd5bf8ac16">topic</a> = willTopic;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#a393e194ac3aee48ef8d535692f5d68fc">msg</a> = willMsg;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#af55fc0e141e96f293c5ce5768b70fd68">msgLen</a> = willMsgSize;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#acac490d66a4fe2969798d187bc2c5776">qos</a> = <a class="code" href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a4f08dfa2b15c80f54bc722a1c4aee136">CC_MqttsnQoS_AtMostOnceDelivery</a>;</div>
<div class="line">    willInfo.<a class="code" href="structCC__MqttsnWillInfo.html#a62a9f84effbd4561c9bee4a7eea46d3d">retain</a> = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = <a class="code" href="client_8h.html#ac48d5a1cbb1f40d5e173b0ed52ec2bb7">cc_mqttsn_client_will_update</a>(client, &amp;willInfo, &amp;my_will_update_complete, someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_ac48d5a1cbb1f40d5e173b0ed52ec2bb7"><div class="ttname"><a href="client_8h.html#ac48d5a1cbb1f40d5e173b0ed52ec2bb7">cc_mqttsn_client_will_update</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_will_update(CC_MqttsnClientHandle client, const CC_MqttsnWillInfo *willInfo, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Update will recorded with the gateway/broker.</div></div>
</div><!-- fragment --><p> Just like with connection request, all the buffers must be preserved by the caller until callback is called. Passing NULL as second parameter (pointer to <a class="el" href="structCC__MqttsnWillInfo.html" title="Will Information.">CC_MqttsnWillInfo</a> structure) as well as assigning NULL or empty string to <b>topic</b> data member of the struct means clearing the will information recorded with the broker.</p>
<p>Another possible way is to update both will topic and will message body separately. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_will_topic_update_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* willTopic = <span class="stringliteral">&quot;updated/will/topic&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> someFunc()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = </div>
<div class="line">        <a class="code" href="client_8h.html#acbe9720f3fed54465a4be18e323a2c7b">cc_mqttsn_client_will_topic_update</a>(</div>
<div class="line">            client, </div>
<div class="line">            willTopic, </div>
<div class="line">            <a class="code" href="common_8h.html#adf1bd91b9b557d00ba1d2fbd604151a6a4f08dfa2b15c80f54bc722a1c4aee136">CC_MqttsnQoS_AtMostOnceDelivery</a>, </div>
<div class="line">            <span class="keyword">false</span>, </div>
<div class="line">            &amp;my_will_topic_update_complete, </div>
<div class="line">            someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_acbe9720f3fed54465a4be18e323a2c7b"><div class="ttname"><a href="client_8h.html#acbe9720f3fed54465a4be18e323a2c7b">cc_mqttsn_client_will_topic_update</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_will_topic_update(CC_MqttsnClientHandle client, const char *topic, CC_MqttsnQoS qos, bool retain, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Update topic of the will recorded with the gateway/broker.</div></div>
</div><!-- fragment --><p> Passing NULL or empty string as will topic parameter will clear the will information registration recorded with the broker.</p>
<p>Updating will message body: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_will_msg_update_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> willMsg[] = {...}</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> willMsgSize = <span class="keyword">sizeof</span>(willMsg)/<span class="keyword">sizeof</span>(willMsg[0]);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> someFunc()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = </div>
<div class="line">        <a class="code" href="client_8h.html#afe494cf426dcb78a1c082107a34bdb56">cc_mqttsn_client_will_msg_update</a>(</div>
<div class="line">            client, </div>
<div class="line">            willMsg, </div>
<div class="line">            willMsgSize, </div>
<div class="line">            &amp;my_will_msg_update_complete, </div>
<div class="line">            someUserData);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclient_8h_html_afe494cf426dcb78a1c082107a34bdb56"><div class="ttname"><a href="client_8h.html#afe494cf426dcb78a1c082107a34bdb56">cc_mqttsn_client_will_msg_update</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_will_msg_update(CC_MqttsnClientHandle client, const unsigned char *msg, unsigned msgLen, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Update will message body recorded with the gateway/broker.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_client_sleep"></a>
Sleeping</h1>
<p>The MQTT-SN protocol supports sleeping clients. It requires to let gateway know about entering the low power mode to cause accumulating the incoming messages with the gateway until clients wakes up.</p>
<p>To notify the gateway use <a class="el" href="client_8h.html#a35628dea3f40a4df46ca202617b48e52" title="Notify gateway about entering the sleep state.">cc_mqttsn_client_sleep()</a> function. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_sleep_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55faa6c651fcaed12bd74b501c4e32aa09fc">CC_MqttsnAsyncOpStatus_Successful</a>) {</div>
<div class="line">        ... <span class="comment">/* Enter low power mode */</span></div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Next communication attempt in 10 minutes (600 seconds)</span></div>
<div class="line"><a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = <a class="code" href="client_8h.html#a35628dea3f40a4df46ca202617b48e52">cc_mqttsn_client_sleep</a>(client, 600, &amp;my_sleep_complete, someUserData);</div>
<div class="line">...</div>
<div class="ttc" id="aclient_8h_html_a35628dea3f40a4df46ca202617b48e52"><div class="ttname"><a href="client_8h.html#a35628dea3f40a4df46ca202617b48e52">cc_mqttsn_client_sleep</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_sleep(CC_MqttsnClientHandle client, unsigned short duration, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Notify gateway about entering the sleep state.</div></div>
</div><!-- fragment --><p> The second parameter specifies time duration in seconds within which the client is going to check for accumulated messages or issue connection/disconnection request.</p>
<p>In order to notify the gateway about return to normal running mode, use <a class="el" href="client_8h.html#ad507e60e9274c03ff1ae0a0952097c27" title="Reconnect to the gateway using previously used client ID and keep alive period.">cc_mqttsn_client_reconnect()</a> message, described in <a class="el" href="index.html#cc_mqttsn_client_connect_disconnect">Connect / Disconnect</a> section.</p>
<p>Check for pending messages to be delivered can be performed using <a class="el" href="client_8h.html#a3948645738ef2cc59aca8431c84676dd" title="Check for accumulated pending messages the gateway has to report.">cc_mqttsn_client_check_messages()</a> function. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_check_messages_complete(<span class="keywordtype">void</span>* userData, <a class="code" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55f">CC_MqttsnAsyncOpStatus</a> status)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="common_8h.html#ade7e7c53c5ca30c6134f60607b01079f">CC_MqttsnErrorCode</a> result = <a class="code" href="client_8h.html#a3948645738ef2cc59aca8431c84676dd">cc_mqttsn_client_check_messages</a>(client, &amp;my_check_messages_complete, someUserData);</div>
<div class="ttc" id="aclient_8h_html_a3948645738ef2cc59aca8431c84676dd"><div class="ttname"><a href="client_8h.html#a3948645738ef2cc59aca8431c84676dd">cc_mqttsn_client_check_messages</a></div><div class="ttdeci">CC_MqttsnErrorCode cc_mqttsn_client_check_messages(CC_MqttsnClientHandle client, CC_MqttsnAsyncOpCompleteReportFn callback, void *data)</div><div class="ttdoc">Check for accumulated pending messages the gateway has to report.</div></div>
</div><!-- fragment --><p> Between issuing the check request and completion callback invocation, there can be multiple exchange of messages between the client and gateway with multiple reports about incoming application messages. After callback is called, the client may return to low power mode again for up to number of seconds provided to initial <a class="el" href="client_8h.html#a35628dea3f40a4df46ca202617b48e52" title="Notify gateway about entering the sleep state.">cc_mqttsn_client_sleep()</a> call. When this period is over again, the client needs to either check for accumulated messages again or reconnect to the gateway (using <a class="el" href="client_8h.html#ad507e60e9274c03ff1ae0a0952097c27" title="Reconnect to the gateway using previously used client ID and keep alive period.">cc_mqttsn_client_reconnect()</a> function).</p>
<h1><a class="anchor" id="cc_mqttsn_client_cancel"></a>
Cancel Existing Operation</h1>
<p>This MQTT-SN client library supports only one asynchronous operation at a time. If current operation takes too much time or there is other more important one to perform, the current operation can be cancelled. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> cancelled = <a class="code" href="client_8h.html#a8a9aee7979efb09f7ab7bea4cc5fd563">cc_mqttsn_client_cancel</a>(client);</div>
<div class="ttc" id="aclient_8h_html_a8a9aee7979efb09f7ab7bea4cc5fd563"><div class="ttname"><a href="client_8h.html#a8a9aee7979efb09f7ab7bea4cc5fd563">cc_mqttsn_client_cancel</a></div><div class="ttdeci">bool cc_mqttsn_client_cancel(CC_MqttsnClientHandle client)</div><div class="ttdoc">Cancel current asynchronous operation.</div></div>
</div><!-- fragment --><p> The return value shows whether the operation was really cancelled. If no operation was in progress, false is returned. If the operation is cancelled, the relevant callback will be invoked with <a class="el" href="common_8h.html#ab0af1cb13f466184b8ecc4b1a86ec55fa3c36cd944f5865d6b7d0055d02750478">CC_MqttsnAsyncOpStatus_Aborted</a> status. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 12 2024 08:40:16 for MQTT-SN Client by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
